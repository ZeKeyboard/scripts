import json
import argparse
import os
import sys
from pathlib import Path
from typing import List, Tuple, Optional

import keycodes

SKELETON = """#pragma once
#include "../common/key_properties.h"

// This file is generated by generate_layout.py. Do not edit manually.

namespace common::constants
{{

const int TOTAL_NUM_KEYS = {total_num_keys};
const int NUM_ROWS = {num_rows};
const int NUM_COLS = {num_cols};

constexpr KeyDescription KEY_PROPERTIES[constants::TOTAL_NUM_KEYS] =
{{
    {rows}
}};

constexpr KeyDescription const* KEY_PROPERTIES_BY_ROW_COL[constants::NUM_ROWS][constants::NUM_COLS] =
{{
    {rows_and_cols}
}};

}}
"""


class KeyDescription:
    def __init__(self, row: int, col: int, x: float, y: float, height: float, width: float, default_key: int, default_key_str: Optional[str]):
        self.row: int = row
        self.col: int = col
        self.x: float = x
        self.y: float = y
        self.height: float = height
        self.width: float = width
        self.default_key: int = default_key
        self.default_key_str: Optional[str] = default_key_str;

    def __str__(self) -> str:
        return f"KeyDescription(row={self.row}, col={self.col}, x={self.x}, y={self.y}, height={self.height}, width={self.width}, default_key={self.default_key}, default_key_str={self.default_key_str})"

    def __repr__(self) -> str:
        return self.__str__()

    def to_cpp(self) -> str:
        return f"KeyDescription {{ {self.row}, {self.col}, {self.x}, {self.y}, {self.height}, {self.width}, {hex(self.default_key)} {'/* ' + self.default_key_str + ' */' if self.default_key_str is not None else ''}}}"


def parse_args():
    parser = argparse.ArgumentParser(description="Generate C++ layout description from keyboard-layout-editor.com")
    parser.add_argument("-i", "--input",
                        help="Path to the input file, generated by keyboard-layout-editor.com",
                        type=Path, required=True)
    parser.add_argument("-o", "--output", help="Path to the generated C++ file.",
                        type=str, default="output.cpp")
    return parser.parse_args()


def extract_col(text: str) -> int:
    """Extracts the column number from the text, e.g. "col1" -> 1, "col10" -> 10"""
    col_half = text.lower().split("col")[1]
    if len(col_half) == 1 or not col_half[1].isdigit():
        return int(col_half[0])
    else:
        return int(col_half[0]) * 10 + int(col_half[1])


def extract_default_key(text: str) -> Optional[str]:
    col_num = extract_col(text)
    text_col_split = text.upper().split(f"COL{col_num}")
    key_first_half = keycodes.KEY_CODE_NAMES.get(text_col_split[0].strip(), None)
    if key_first_half is not None:
        return key_first_half
    return keycodes.KEY_CODE_NAMES.get(text_col_split[1].strip(), None)


def parse_json_layout(json_layout) -> Tuple[List[List[KeyDescription]], int]:
    max_col = 0
    curr_y = 0
    rows = []
    for row_num, row in enumerate(json_layout):
        curr_y += 1
        cols = []
        curr_x = 0
        width = 1
        set_width = False
        height = 1
        set_height = False
        for item in row:
            if isinstance(item, dict):
                if "y" in item:
                    curr_y += item["y"]
                if "x" in item:
                    curr_x += item["x"]
                if "w" in item:
                    width = item["w"]
                    set_width = True
                if "h" in item:
                    height = item["h"]
                    set_height = True
            else:
                if not set_width:
                    width = 1
                if not set_height:
                    height = 1

                col_num = extract_col(item)
                default_key_str = extract_default_key(item)
                default_key = keycodes.KEY_CODES.get(default_key_str, 0)
                key = KeyDescription(
                    row=row_num,
                    col=col_num,
                    x=curr_x,
                    y=curr_y,
                    height=height,
                    width=width,
                    default_key=default_key,
                    default_key_str=default_key_str)
                cols.append(key)

                curr_x += width
                set_width = False
                set_height = False

                max_col = max(max_col, col_num)

        rows.append(cols)
    return rows, max_col


def get_row_col_grid(rows: List[List[KeyDescription]], max_col: int) -> List[List[Optional[int]]]:
    grid = [[None] * (max_col + 1) for _ in range(len(rows))]
    index = 0
    for row in rows:
        for key in row:
            grid[key.row][key.col] = index
            index += 1
    return grid


def write_cpp(rows: List[List[KeyDescription]], max_col: int, output_path: str):
    num_rows = len(rows)
    num_cols = max_col + 1
    total_num_keys = sum([len(row) for row in rows])

    rows_str = ",\n    ".join([",\n    ".join(
        [key.to_cpp() for key in row]) for row in rows])

    grid = get_row_col_grid(rows, max_col)
    grid_rows = []
    for row_index, row in enumerate(grid):
        grid_cols = []
        for index in row:
            if index is None:
                grid_cols.append("nullptr")
            else:
                grid_cols.append(f"&KEY_PROPERTIES[{index}]")
        row = ",\n        ".join(grid_cols)
        grid_rows.append(f"{{\n        // Row {row_index}\n        {row}\n    }}")
    rows_and_cols = ",\n    ".join(grid_rows)

    cpp = SKELETON.format(
        total_num_keys=total_num_keys,
        rows=rows_str,
        num_rows=num_rows,
        rows_and_cols=rows_and_cols,
        num_cols=num_cols)
    with open(output_path, "w") as f:
        f.write(cpp)


def main():
    args = parse_args()
    if not os.path.isfile(args.input):
        print(f"Input file {args.input} does not exist.")
        sys.exit(1)

    json_layout = None
    with open(args.input) as f:
        json_layout = json.load(f)

    rows, max_col = parse_json_layout(json_layout)
    write_cpp(rows, max_col, args.output)


if __name__ == "__main__":
    main()
